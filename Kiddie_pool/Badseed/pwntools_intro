#!/usr/bin/env python3
from pwn import *
import ctypes

fname = 'python3'		
ip = '0.0.0.0'#change this
port = 1234 #change this



LOCAL = True

if LOCAL:
    p = process(fname,aslr=True)

    gdbscript="""
    b *main
    """

    #attach(fname,gdbscript=gdbscript)
else:
    r = remote(ip, port)




s = lambda x : p.send(x)
sl = lambda x : p.sendline(x)
sla = lambda x,y : p.sendlineafter(x,y)

rl = lambda : p.recvline()
rb = lambda x :p.recvb(x)
ru = lambda x :p.recvuntil(x)
rall = lambda :p.recvall()

inter = lambda : p.interactive()


def pwn():


	#sendline(data) sends data and appends a '\n' 
	sl(b"print('Hello world')")
	sl(b"print('Wow, such data')")

	var1 = b"print('Hello moon')"
	sl(var1)

	#you can send bytes as well  ... print('Ayy, more data') in bytes format
	sl(b"\x70\x72\x69\x6e\x74\x28\x27\x41\x79\x79\x2c\x20\x6d\x6f\x72\x65\x20\x64\x61\x74\x61\x27\x29")


	#send(data) sends data without appending a '\n'
	s(b"print('bye bye')")

	p.shutdown('send')

	#recieving data
	line1 = rl() 
	line2_3 = ru('Hello moon')
	newline = rb(1) #this will read the newline that is left from line 3
	rest = p.recvall() 

	print(line1)
	print(line2_3)
	print(newline)
	print(rest)
	print('\n')

	log.info('some randome log message')
	log.info('and another one')
	print('\n')

	progress = 0
	brute = log.progress('Working')
	for i in range(500):
		brute.status(f'bruteforcing canary {i}/500')
		sleep(0.01)
	brute.success('Got a shell!')
	print('\n')



	#convertig recieved data (in this case a x64 mem addr) to usable format

	leaked_addr = b'\x90\x80\xdc\xff\xff\x7f\x00\x00'
	print(f'this is the leaked addr you recieved with rl() = {leaked_addr}')

	unpack1 = u64(leaked_addr) #u64 requires 8 bytes there are also u32 and more
	unpack2 = unpack(leaked_addr,'all',endian='little') #unpack() can unpack any length of bytes
	print('unpacked with 1st method = ' + hex(unpack1))
	print('unpacked with 2nd method = ' + hex(unpack2))
	print('\n')
	offset = 0x28499 
	unpack1 = unpack1 + offset
	

	#converting back so that we can send it

	pack1 = p64(unpack1)  #p64 there are also p32 and more
	pack2 = pack(unpack2,'all',endian='little')

	print('addet offset and packed with 1st method = ' + str(pack1))
	print('")" represents the "\\x29" byte which is printable ... but this addr is not realy readable for us so we convert it to hex that makes it easier to read = ' + pack1.hex()) #to make the addr a bit more readable but its still in wrong endianenes
	print('no offset addet and packed with 2nd method = ' + str(pack2))
	print('\n')

	#creating a pattern to find rip offset
	print(cyclic(200))
	

	#find a pattern
	offset = cyclic_find(b'xaab')
	print(f'pattern found at offset = {offset}')
	print('\n')



	#assembler/disassembler functions (usefull for shellcoding challenges)

	#set context 
	context.clear()
	context.update(arch='amd64')
	context.bits == 64
	context.endian == 'little'

	payload = b''
	payload += asm("""
		xor rax, rax
		xor rdi, rdi
		xor rsi, rsi
		xor rdx, rdx
		""")

	print('this is the disassembly')
	print(disasm(payload))
	print('')

	print(f'this is the payload in bytes format = {payload}')
	print(f'this is the payload in hex format = {payload.hex()}')
	print('\n')



	#using c libc functions in python code
	#remember that we imported ctypes
	libc = ctypes.CDLL('/lib/x86_64-linux-gnu/libm.so.6')

	libc.srand(libc.time())
	number = libc.rand()
	print(f'this is a randome number generated by the c rand() = {number}')
	print('\n')

	inter()
 
if __name__ == '__main__':
    pwn()

